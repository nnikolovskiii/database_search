# RAG System for SQL Query Generation

#### GitHub repository
[https://github.com/Dpavlovski/SQL-Generator-](URL)

#### Running the Project

#### Prerequisites

Ensure you have [Poetry](https://python-poetry.org/docs/#installation) installed on your system.

#### Installation

1. Clone the repository:

    ```bash
    git clone https://github.com/Dpavlovski/SQL-Generator-.git
    cd your-repo
    ```

2. Install the dependencies:

    ```bash
    poetry install
    ```

### Running the Application

To run the application, use the following command:

```bash
poetry run python main.py
```

## Project Overview

### Register Database
The software functions as a chatbot designed to handle database-related questions from users, returning a generated SQL query along with a limited output of 5 records as a response. To enable the bot to generate accurate queries, the user must first register a database via one of the API endpoints. This involves providing the database connection details, including the database name, username, password, host, port, and schema.

Once the database connection string is provided, the integration process begins. Initially, the connection details are securely stored, allowing the system to access the database whenever needed.

### Embedding Process
Next, the embedding process starts, where all table names and their corresponding column names are transformed into vectors and stored in a vector database—in this case, a Qdrant collection. Each embedding is enriched with metadata, including `table_name`, `column_name`, and `value`, which represent the source table and column (e.g., an embedding for the value "201517" would have `table_name=student`, `column_name=index`, and `value=201517`). This metadata enhances the system’s ability to search and retrieve relevant data from the collection. After embedding in Qdrant, similar embeddings are clustered together, facilitating the identification of the most relevant tables and columns when a user queries the chatbot.

### Graph Database Integration
The next step involves inserting the tables and columns into a graph database using Neo4j. This graph database effectively represents the relationships between the tables and their columns, further improving the accuracy and relevance of the SQL queries generated by the system. With the integration complete, users can select the database from a dropdown list and begin querying it.

## SQL Query Generating Pipeline

### Initial Prompt Validation
When a user submits a natural language query (e.g., “Give me all students who applied for diploma thesis”), the chatbot initiates a sophisticated processing pipeline designed to accurately generate SQL queries. The first step is to determine whether the prompt is related to database querying. If the system identifies that the prompt cannot be processed into an SQL query (e.g., if it's a general question unrelated to the database), the bot will respond with an explanation, guiding the user towards a more relevant query.

### Named Entity Recognition (NER)
If the prompt is valid, it proceeds to the next chain, where OpenAI is leveraged to act as an expert in named entity recognition (NER). Here, the system extracts key entities from the query, such as table names, column names, and specific values. This step is crucial for understanding which parts of the database are relevant to the query.

### Similarity Search in Qdrant
Using the extracted entities, the system searches through the Qdrant collection to find the most similar matches. This involves comparing the entities to the embeddings stored in Qdrant to determine whether they correspond to a table name, a column name, or a specific value within the database. The system retrieves the closest matches, ranking them based on their relevance.

### Relationship Mapping with Neo4j
After identifying the relevant tables and columns, the system uses Neo4j to explore the relationships between these entities. Neo4j’s graph database contains all the relationships between tables and columns, allowing the system to determine which related tables should be included in the SQL query. This ensures that the generated query is comprehensive and correctly joins related data.

### SQL Query Generation
Finally, with all the necessary information gathered, the system generates the SQL query. It selects the appropriate tables, applies the relevant conditions, and constructs a query that is both accurate and optimized. The generated query is then executed against the database, and the system returns a limited set of results (typically the top 5 records) to the user, along with the SQL query itself.

## Conclusion
This structured approach ensures that even complex user prompts are handled with precision, making the chatbot an effective tool for interacting with relational databases through natural language.


## API Endpoints

### 1. Register Database

- **Endpoint:** `/database/add`
- **Method:** `POST`
- **Description:** Registers a new database by saving its connection details.
- **RequestParam: include_values(true/false)**
- **Request Body:**
  ```json
  {
    "dbname": "your_database_name",
    "user": "your_username",
    "password": "your_password",
    "host": "your_host",
    "port": "your_port",
    "schema": "your_schema"
  }

### 2. Chat 

- **Endpoint:** `/chat`
- **Method:** `POST`
- **Description:** .
- **Request Body:**
  ```json
  {
    "prompt": "your_prompt"
  }